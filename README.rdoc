1. Stworzmy sklep
   * Nasz sklep bedzie wyposazony w skryp ktory bedzie sluzyl do wygnerowania losowych prodkuktow
     kategori oraz obrazkow
   * Bedzie mozna wejsc do kazdego prodkutu, zamowic go z poziomu produktu
   * Jak rownież z pozoimu kategorii takze bedzie mozna dokanac zamowien
   * Bedzie mial pelna nawigacje
   * Na gorze strony bedzie koszyk z podgladem ile mamy produktowy w koszyku i ile bedzie nasz kosztowac zamowienie
   * Bedziemy miele formularz dostawy i rodzaj dostawy
   * Bedziemy mieli potwerdzenie zamowienia i gdy wyslemy zamowienie bedzie wysylany mail z potwierdzeniem
   * Bedzie posiadal panel admina, zabezpieczony haslem
   * Bedziemy mieli mozliwosc zarzadzaniem produktami z poziomu admina
   * Mozliwosc przesukiwania prodkutow
   * Sklep bedzie takze sledzil status zamowienia

  * rails g Shop_Online -d mysql



  * Pierwsza rzecz to dodanie potrzebnych gemow (wiekaszosc naraz dodam)

                gem 'faker'                     # sluzy do generowania danych ktore sa falszywe ale wygladaja na prawdziwe
                gem 'letter_opener'             # sluzy do generowania malera i ktory nie jest wysylany tylko pokazuje zawartos maila
                gem 'carrierwave'               # zalanczanie plikow i przetwarzanie ich do miniatuerk
                gem 'mini_magick'               # dodatek do carrierwawe i sluzy do przetwarzania miniatuerk
                gem 'simple_form'               # proste generownaie formularze
                gem 'twitter-bootstrap-rails'   # bibloteka dodajaca nam bootstrapa do projektu
                gem 'ransack'                   # sluzy do generowania formularzy wyszukiwania (np. do przeszukiwania produktow)
                gem 'kaminari'                  # sluzy do paginacji
                gem 'rails-i18n'                # sluzy do spolszczenia polskich komunikacji
                gem 'statesman'                 # sluzy do maszyny stanow (czyli rozne statusy: nowe, potwirdzony, anulowano, oplacony czyli przelancza nas z jednego stanu w drugi np. ze przesylka zostala nadana)
  * bundle
  ** config/environments/development.rb
     - i ustawiamy zeby maile wysylane byle przez letter_openera:
           # Czyli zamiast wysylac prawdziwego maila - bedziemy te maile otwierac w przegladarce
            config.action_mailer.delivery_method = :letter_opener
  ** config/application.rb
     - i ustawienie jezyka polskiego
           config.i18n.default_locale = :pl
           dziki temu komiunikaty o bledach beda automatycznie spolszczone


  9.2 Zaplanowanie prac ze sklepem, wygenerowanie szablonow
       ( Instalcja_podstawych_skladowych_sklepu_mni_bootstrap_modele_kontrolry)
    * Najpierw wygenerujemy bootstrapa       - rails g bootstrap:install static
    * Instalacja kaminari dla bootstrapa     - rails g kaminari:views bootstrap3
    * Simpe_form kompatybilny z bootstrapem  - rails g simple_form:install --bootstrap   (https://github.com/plataformatec/simple_form)

   ** Czas na wygenerowanie kontrollerow:
       - rails g controller products index show  (tu potrzebujemy tylko dwuch akcji)
       - rails g controller categories show      (dodamy mozliwosc wyswietlania zawartosci kategori, czyli tylko jednej akcji show)
       - rails g controller static terms privacy shipping about ( potrzebujemy kontrollera ktory bedzie przechowywal nasze statyczne strony typu, regulamin czy polityka sklepu)
                        zawiera:
                                terms     - regulamin,
                                privacy   - polityka prywatnosci,
                                shipping  - informacje na temat dostawy i
                                about     - informacje o sklepie )
   ** Teraz modele
      - rails g model category name:string  (Wiemy ze napewno bedziemy mieli produkty podzielone na kategorie, wiec z tad model o nazwie kategoraria i bedzie posadala name)
      - rails g model product  name:string description:text long_description:text photo:string price:decimal category:belongs_to
                        wiemy takze ze musimy miec produkty ktore beda zwierac:
                        name                  - nazwe
                        description           - opis
                        long_description      - dluzszy opis, bedziemy wyswietlac go tylko w szczegolach danego produktu
                        photo                 - pole do przechowywania sciezki do zdjecia danego produktu
                        price                 - cena
                        category:belongs_to   - ostatecznie produkt bedzie nalezal do jakiejs kategorii
   ** Wiemy, ze produkty beda posadaly zdjaca.  Wiec musimy wygenerowac uploader dla CarrierWave czyli plikow ze zdjeciami oraz ich obrubke, np. generowanie miniatur o odpowiednim rozmiarze tak aby pasowaly do desingu
      - rails generate uploader product_photo
          app/uploaders/product_photo_uploader
                  include CarrierWave::MiniMagick                       # Odchaczamy nasz modul, minimagic odpowiada za intergracje z carierrwave
                                                                        # i to walanie on dokonuje prztwarzania wszystkich obrazkow na miniatury itd.
                                                                        # Jezeli nie zaimplementujemy tego modulu to carrierwave nie bedzie wiedzial w jaki sposob wykonac
                                                                        # metode resize_to_fit * rake db:create    - poniewaz mamy mysql
                                                                        # I ten modul wlasnie odpowiada za obsluge obrazkow
   * rake db:migrate

   9.3 Skonfigurowanie_adresow_url_oraz_modeli
      * Zacznijmy od przygotowania naszego uploadera do odpowiedniego przyjmowania plikow
        app/uploaders/product_phot_uploader.rb
          - gdy zjedziemy nizej to widzimy ze mamy udokumentowany sposob na przechowywanie wersji,
          - nam bedzie potrzebny do miniaturki i orginalny rozmiar
                        # Create different versions of your uploaded files:
                        # version :thumb do
                        #   process :resize_to_fit => [50, 50]
                        # end
          - My damy sobie tak:
                          version :thumb do
                            process :resize_to_fit => [120, 120]
                          end

                          version :details do
                            process :resize_to_fit => [640, 480]
                          end
          - Oraz odznaczamy :
                          include CarrierWave::MiniMagick                       # Odchaczamy nasz modul, minimagic odpowiada za intergracje z carierrwave
      ** Teraz model z kategoria
         - kategoria posiada wiele produktow i produkty naleza do kategorii polaczmy modele
                  class Category < ActiveRecord::Base
                    has_many :products                   # liczba mnoga poniewaz mamy wiele produktow
                    validates :name, presence: true      # zrobmy odrazu walidacje na to pole
                  end
      ** Nastepnie model z produktami
         - generator rails juz nam polaczyl model
         - dodajmy szereg walidacji
               class Product < ActiveRecord::Base
                 belongs_to :category
                 validates :name, presence: true                        # pole z nazwa nie moze byc puste
                 validates :description, presence: true                 # pole z opisem nie moze byc puste
                 validates :price, numericality: { greater_than: 0.0 }  # cena powinna byc wieksza niz zero i musi byc liczba
                 validates :category, presence: true                    # deklarujemy ze chcemy ja zwalidowac i przypozadkowac do kategorii

                 mount_uploader :photo, ProductPhotoUploader         # Musimy takze zamontowac nasz uploader pochodzacy z gemu CarrierWave
                                                                     # Jako argument przkazujemy nazwe photo, ktora bedzie przechowywala sciezke do pliku
                                                                     # Oraz nazwe klasy, ktora obsluguje dane uploadsy
               end

      ** Teraz plik z routsami
        - Ustawmy nasze główne configi
            resources :products, only: [:show, :index]     # nasz resources products bedzie posiadal tylko dwie akcje
            resources :categories, only: [:show]           # dodatkowo zadeklarujemy kategorie ktora bedzie posiadala tylko jedna akcje
            root to: 'products#index'                      # i nasz glowny adres

        - Warto ustwic jak beda wygladaly adresy url naszych statycznych stron
             get 'regulamin', to: "static#terms", as: :terms                # Czyli wchodzac do akcji (slesh regulamin) /regulamin, bedziemy kierowac do kotrollera static i akcji terms i url nazwiemy terms (termss_path)
             get 'polityka-prywatnosci', to: "static#privacy", as: :privacy
             get 'dostawa', to: "static#shipping", as: :shipping
             get 'o-sklepie', to: "static#about", as: :about

        * Odpalmy nasz serwer


9.4 Szkice listy produktow
    ** Teraz zajmniemy sie zaplanowaniem desingu naszego sklepu
     - zapelnimy go falszywymi danymi od fakera - tylko po to zeby zobaczyc jak bedzie wygladac
     - naszkicujemy nasz layots i szczegoly naszego leyoutu
     - linki gorne naszego menu
     - gorna belka nawigacyjna

     ** Nawigacja - fac, ale to Zajebiste,
      * Cala belka nawigacyjna jest oparta o klasy bootstrap

        <nav class="navbar navbar-inverse navbar-static-top">     <!-- navbar-inverse, ta klasa domyslnie ma odwrocone kolory, ale teraz bedzie ciemna i bedzie miala bialy tekst -->
          <div class="container">
            <div class="navbar-header">
              <a class="navbar-brand" href="<%= root_path %>">Robo</a>
            </div>
            <ul class="nav navbar-nav">
              <li <% if [params[:controller], params[:action]] == ["products", "index"] %>class="active"<% end %>><%= link_to "Start", root_path %></li>
              <li <% if [params[:controller], params[:action]] == ["static", "privacy"] %>class="active"<% end %>><%= link_to "Polityka prywatności", privacy_path %></li>
              <li <% if [params[:controller], params[:action]] == ["static", "terms"] %>class="active"<% end %>><%= link_to "Regulamin", terms_path %></li>
              <li <% if [params[:controller], params[:action]] == ["static", "shipping"] %>class="active"<% end %>><%= link_to "Regulamin", shipping_path %></li>
              <li <% if [params[:controller], params[:action]] == ["static", "about"] %>class="active"<% end %>><%= link_to "O sklepie", about_path %></li>
            </ul>
          </div>
        </nav>

     ** Teraz wchodzac w start m.innymi na pasku nawigacji
        - rails s i widzimy nasz szablonik
        - bedziemy chceli miec pasek boczny (sidebar)
        - czyli tkzw. linki, beda po lewej w pionie
        - a po prawej stronie tresc strony
        - wszystkie te klasy ponizej sa wbudowane w bootstrapa

          <div class="container-fluid">
             <div class="row">                                     # Wszystko przechowujemy w divie o klasie row, i ktory przechowuje wiersz o systemie girdowym bootstrapa
               <div class="col-md-2">
                 <h3>Kategorie</h3>
                     <ul class="nav nav-sidebar">
                       <% (1..9).each do |category|%>              # Tutaj generamy 9 linkow do kategori
                           <li>
                             <%= link_to "Kategoria#{category}", category_path(category) %>
                           </li>
                       <% end %>
                     </ul>
               </div>
               <div class="col-md-10">
                 <%= yield %>
               </div>
             </div>
          </div>


          # gird jest pewnym systemem klockow o danym rozmiarze do ktorych wpisujemy tresc czyli:
              <div class="col-md-2">     -> ta klasa, nazywa sie col-md-2, dwujka oznacza tutaj dwie kratki w systemie gridowym
                                         -> bootstrapowy gird zawiera 12 kratek
                                         -> a my uzywamy dwuch dwunastych 2/12 czyli 1/6 miejsca na ekranie na sidebar

               <div class="col-md-10">   -> oraz 10/12 dziesiec dwunastych, czyli 5/6 na pozostala tresc
                                         * Jezeli bysmy zmienili ten gorny na md-4, a dolny na md-8 to
                                           wtedy bysmy mieli 4/12 i 8/12 to oczywiscie sidebar bedzie mial wieksza szerokkosc
                                           ale za to bedziemy mieli miej miejsca na zawartosc strony
          # Czyli bootstrap daje nam bardzo wygodne klasy do lokowania tresci zgodnie z layotsem kolumnowm






   ** Teraz na naszej glownej stronie chcemy wyswietlic najnowszych produktow
    * Wchodzimy na nasza głowna strone  views/products/index

      <%= (1..9).each_slice(3) do |slice| %>                                                       <!-- Bedziemy wyswietlac 9 elementow, wiec od 1 do 9 sobie wyliczymy i uzyjemy helpera  each_slice ktory nam podzieli te tablice na iles tablic, ktora kazda z nich bedzie zawierala po trzy elementy -->
          <div class="row">                                                                        <!-- Produkty bedziemy wyswietlac w 3 kolumnach wiec uzyjemy systemu gird z bootstrapa -->
            <% slice.each do |product| %>                                                          <!-- Kazda z tych trujek jest tablica po ktorej bedzimey literowac -->
                <div class="col-md-4">                                                             <!-- Skoro chcemy 3 produkty w kazdym wierszu, i skoro mamy 12 kratek w naszym girdzie, to kazdy produkt zajmnie 1/3 z tych 12 czyli 4kratki   -->
                  <div class="thumbnail">                                                          <!-- Z kolieji ta klasa jest klasa ktora reprezentuje miniaturke -->
                    <%= link_to product_path(product) do %>                                              <!-- link_to przyjmuje zazwyczaj parametr jakis tekst, natomiast drugi to jakas sciezka, natomiat kiedy nie podamy mu tekstu do linku i uczynimy ten helper blokowym (do i end) to zamiast scizki linkowej mozemy miec jako link np. OBRAZEK, WIEC JEZELI CHCEMY ZALINKOWAC OBRAZEK UZYWAMY DO zeby zasignalizowac ZE BEDZIE TO link blokowy i  tresci tego uzyjemy image_taga-->
                        <%= image_tag Faker::Placeholdit.image("640x480", 'jpg', 'cccccc') %>      <!-- Faker oferuje nam skorzystanie z serwisu http://placehold.it i wygenerowac nam obrazki o danym rozmiarze-->
                    <% end %>
                    <div class="caption">
                      <h3><%= link_to Faker::Hacker.noun.titleize, product_path(1) %></h3>                  <!-- Tu mamy nazwe produkut z uzyciem helpera Faker::Hacker.noun -->
                      <p><%= simple_format(truncate(Faker::Hacker.say_something_smart, length: 90)) %></p>  <!--  Tutaj opis danego produktu, czyli jakies wygenerowane zdanie przez fakera -->
                      <p class="lead"><%= number_to_currency Faker::Number.decimal(2, 2) %></p>             <!--  I tutaj cena danego produktu-->
                      <p>
                        <%= link_to "#", class: "btn btn-primary" do %>
                          <span class="fa fa-shopping-cart"> Dodaj do koszyka             <!-- I tu mamy bardzo ciekawa klase bootstrapa fa dlatego ze mamy strone http://fontawesome.io  czyli ikonki, fa-to pierwsza klasa ze to fontawsome i druga klasa to opis ikonik-->
                        <% end %>
                      </p>
                    </div>
                  </div>
                </div>
            <% end %>
          </div>
      <% end %>

      - rails s
      - po odswiezeniu strony nazwy sie beda zmieniac, poniewaz sa generowane losowo przez nasz helper Faker
      ** Dodajmy teraz naglwej ze sa to produkty najnowsze
               <h1>Najnowsze produkty</h1>


      ** Chcemy zeby nasz widok z lista produktow  byl widoczny takze gdzie indziej wiec zrobimy go parshalem
           <%= render partial: 'products', locals: { products: (1..9) } %>       -> wywolamy renderowanie parszala, i do niego przekazemy zmienna
      ** Tworzymy parshala
         - wycinamy kod z index.html.erb
         - tworzymy nowy _products.html.erb
         - wklejamy nasz wyciety kod


               <%= (1..9).each_slice(3) do |slice| %>                                                       <!-- Bedziemy wyswietlac 9 elementow, wiec od 1 do 9 sobie wyliczymy i uzyjemy helpera  each_slice ktory nam podzieli te tablice na iles tablic, ktora kazda z nich bedzie zawierala po trzy elementy -->
                   <div class="row">                                                                        <!-- Produkty bedziemy wyswietlac w 3 kolumnach wiec uzyjemy systemu gird z bootstrapa -->
                     <% slice.each do |product| %>                                                          <!-- Kazda z tych trujek jest tablica po ktorej bedzimey literowac -->
                         <div class="col-md-4">                                                             <!-- Skoro chcemy 3 produkty w kazdym wierszu, i skoro mamy 12 kratek w naszym girdzie, to kazdy produkt zajmnie 1/3 z tych 12 czyli 4kratki   -->
                           <div class="thumbnail">                                                          <!-- Z kolieji ta klasa jest klasa ktora reprezentuje miniaturke -->
                             <%= link_to product_path(product) do %>                                              <!-- link_to przyjmuje zazwyczaj parametr jakis tekst, natomiast drugi to jakas sciezka, natomiat kiedy nie podamy mu tekstu do linku i uczynimy ten helper blokowym (do i end) to zamiast scizki linkowej mozemy miec jako link np. OBRAZEK, WIEC JEZELI CHCEMY ZALINKOWAC OBRAZEK UZYWAMY DO zeby zasignalizowac ZE BEDZIE TO link blokowy i  tresci tego uzyjemy image_taga-->
                                 <%= image_tag Faker::Placeholdit.image("640x480", 'jpg', 'cccccc') %>      <!-- Faker oferuje nam skorzystanie z serwisu http://placehold.it i wygenerowac nam obrazki o danym rozmiarze-->
                             <% end %>
                             <div class="caption">
                               <h3><%= link_to Faker::Hacker.noun.titleize, product_path(1) %></h3>                  <!-- Tu mamy nazwe produkut z uzyciem helpera Faker::Hacker.noun -->
                               <p><%= simple_format(truncate(Faker::Hacker.say_something_smart, length: 90)) %></p>  <!--  Tutaj opis danego produktu, czyli jakies wygenerowane zdanie przez fakera -->
                               <p class="lead"><%= number_to_currency Faker::Number.decimal(2, 2) %></p>             <!--  I tutaj cena danego produktu-->
                               <p>
                                 <%= link_to "#", class: "btn btn-primary" do %>
                                     <span class="fa fa-shopping-cart"></span> Dodaj do koszyka             <!-- I tu mamy bardzo ciekawa klase bootstrapa fa dlatego ze mamy strone http://fontawesome.io  czyli ikonki, fa-to pierwsza klasa ze to fontawsome i druga klasa to opis ikonik-->
                                 <% end %>
                               </p>
                             </div>
                           </div>
                         </div>
                     <% end %>
                   </div>
               <% end %>


       ** Teraz chcemy tego parshala uzyc w innym miejscu np. w views/categories/show
          - uzyjemy kodu podobnego do produktu

          <h1>Nazwa kategori</h1>

          <%= render partial: 'products/products', locals: { products: @products } %>

          <!-- Poprzednia nazwa parshala nie zadziala  ( wersja z innego kontrollera <%= render partial: 'products', locals: { products: (1..9) } %> )
               poniewaz railsy beda szukac praszala wylacznie
               wewnatrz categories, a nasz parszal pochodzi z innego źrudla
               ale jak railsom podamy pelna nazwe controllera czyli products i nazwe parszala czyli products
               to railsy je znajda bez problemu
               i wtedy wyswietli nam sie oczekiwany rezultat
           -->



9.5 .Szkic_szczegolow_produktu
     views/products/show
     - Zrobimy tak, ze po prawej stronie mamy obrazek,
       - pomiedzy obrazkiem a paskiem bocznym: nazwe produktu, opis, szczegoly i przycisk
        
              <div class="container-fluid">
                <div class="col-md-5">                                                       <!-- Tutaj takze korzystamy z girda bootstrapowego, bedzie zajmowa 5/12 miejsca na takie rzeczy jak opis, nazwe produtkow, cenne -->
                  <h1><%= Faker::Hacker.noun %></h1>
                  <p class="lead"><%= Faker::Hacker.say_something_smart %></p>
                  <%= simple_format(Faker::Lorem.paragraphs(3).join("\n\n")) %>

                  <p class="lead"><%= number_to_currency(Faker::Number.decimal(2, 2)) %></p>
                  <p>
                    <%= link_to "#", class: "btn btn-primary" do %>
                      <span class="fa fa-shopping-cart">  Dodaj do koszyka </span>
                    <% end %>
                  </p>
                </div>
                <div class="col-md-7">                                                         <!-- A po prawej stronie mamy 7/12 zajmowanego miejsca, kiedy obrazek bedzie zbyd duzy na obszar jaki mu dano, to obrazek bedzie pomniejszony i dostosowany do danego miejsca  -->
                  <%= image_tag Faker::Placeholdit.image("640x480", 'jpg', 'cccccc'), class: "img-responsive" %>
                </div>
              </div>


9.6 Skrypt_generowania_losowych_testowych_produktow
    **
    Napiszemy skrypt, ktroy stworzy prawdziwe wpisy do bazy danych - uzywajac fakera do wygenerowania wartosci do naszych pol
    - i kiedy bedziemy wyswitlac nasze produkty z prawidzwymi danymi to nasz sklep bedzie bardziej znacznie kolorowy niz jest aktualnie szere placehodery
    - Potencjalnie dobrym miejscem dla wygenerownia takiego skryptu jest miejsce /db/seeds.rb
    - Do tego pliku dodaje sie zawyczaj dane ktore umozliwiaja uruchomienie aplikacji
      db/seeds.rb

          ShippingType.create name: "Paczka Pocztowa", cost: 10.0
          ShippingType.create name: "Kurier", cost: 20.0


         8.times do                                                   # W tym bloku losujemy 8 kategori
           Category.create! name: Faker::Hacker.ingverb.capitalize    # Tu tworzymy nowe kategorie z losowa nazwa wygenerowana przez Fakera
         end

         category_ids = Category.pluck(:id)                           # Tutaj przechowuje w zmiennej wszystkie numery id tych kategorii,
                                                                      # metoda pluck  w active record przyjmuje 1argument w postaci nazwy kolumny
                                                                      # i ta metoda zwraca tablice z wartosciami w tej kolumnie wszystkich wierszy w bazie dannych

         print "Product "
         200.times do       # nastepnie 200 razy wywolujemy ten blok, i w nim dodajemy produkty
           product = Product.create! name: "#{Faker::Hacker.verb} #{Faker::Hacker.noun}".capitalize, # dajemy naze
                                     description: Faker::Hacker.say_something_smart,                 # wywolujemy krotki opis
                                     long_description: Faker::Lorem.paragraphs(3).join("\n\n"),      # Wywolujemy dlugi opis
                                     category_id: category_ids.sample,                               # wybieramy losowa kategorie, czyli na tablicy z wszystkimi identyfikatorami kategorii wywolujemy metode sample, ktroy zwraca losowy element z tej tablicy
                                     price: Faker::Number.decimal(3, 2)                              # generujemy losowa cene
           product.remote_photo_url = Faker::Avatar.image(                   # Generujemy losowy obrazek produktu
               product.name.parameterize,
               "640x480",                  # ma miec rozmiar
               "jpg",                      # byc w formacie jpg
               "set#{[1, 2, 3].sample}",   # obrazek ma byc wykorzystany ze wszystkich setow 1-set wyswietla roboty, 2-set twarze robotow, 3-set potworki
               "bg#{[1, 2].sample}"        # tutaj mowimy z ktorego tla losoego bedziemy korzystac
           )
           product.save   # zapisujemy produkt
           print "."      # kropecza sygnalizuje nam ze cos sie dzieje poniewaz skrytp bedzie dzialal dosc dlugo, ze sie nie zawiesil, nie zapetlil
         end
         puts             # i wyswitlamy

    - Tak napisany skrypt mozemy wywolac
      rake db:seed
    - Musimy teraz usunac bd i stworzyc na nowo, wprowadzic wszystkie dane:
       rake db:drop     - usowa bd
       rake db:create   - tworzy bd
       rake db:migrate  - odpala migracje
       rake db:seed     - odpala skrypt

       rake db:drop db:create db:migrate db:seed        ->  to wszsytko mozemy wykonac za pomoca jednego polecenia
       widzimy ze wszystko dzila, i nasz skrypt wyswietla kropeczki (bedzie ich 200)

 9.7 Wyswietlanie produktow w bd
     **
     Nasze losowe dane zostaly juz dodane do bazy danych
     - teraz mozemy przystapic do ich wyswietlenia

     **
     Zaczniemy od pliku z layotem, chcemy wyswietlac prawdziwe kategorie

                   <!-- Nasz sidebar - pasek boczny -->
                      <div class="container-fluid">
                        <div class="row">
                          <div class="col-md-2">
                            <h3>Kategorie</h3>
                            <ul class="nav nav-sidebar">
                              <% Category.all.each do |category| %>                        <!-- Wyswitlmy teraz prawdziwe kategorie -->
                                  <li>
                                    <%= link_to category.name, category_path(category) %>  <!-- 1-argumenty to category, a 2gim argumentem bedzie sciezka do category -->
                                  </li>
                              <% end %>
                            </ul>
                          </div>
                          <div class="col-md-8">
                            <%= yield %>
                          </div>
                        </div>
                      </div>


      - odswiezmy strone
      - widzimy ze mamy teraz prawdziwe kategorie
      - teraz jak wchodzimy do kategorii po pierwsze powinna nam sie wyswietlic nazwa kategori a nastepnie produkty
      - wchodzimy do kontrollera controllers/categories_controller.rb


              class CategoriesController < ApplicationController
                def show
                 @category = Category.find(params[:id])                        # i w akcji show powininsmy znalesc kategorie ktora chcemy wysietlac
                 @products = @category.products.page(params[:page]).per(6)     # a po drugie znalezc produkty z tej kategorii i dodamy paginacje, na kazdej stronie 6produktowend
              end

     - I teraz w widkou views/categories/show dajmy prawdzwe dane
                 <h1><%= @category.name  %></h1>

                 <%= render partial: 'products/products', locals: { products: @products } %>

                 <!-- Dodajmy paginacje -->
                 <%= paginate @products %>
     - Odswiezamy strone i widzimy ze jest tak jak nalerzy
     **
     - Gdy przewiniemy strone widzimy paginacje, ktora nie wyglada za ladnie
     - Pamietamy ze dodajac kaminari do projektu wygenerowalismy takze paginacje i teraz ja usuniemy
     - usowamy next last oraz first, prev

     views/kaminari/_paginator.html.erb
                        <%= paginator.render do -%>
                          <ul class="pagination">
                            <% each_page do |page| -%>
                              <% if page.left_outer? || page.right_outer? || page.inside_window? -%>
                                <%= page_tag page %>
                              <% elsif !page.was_truncated? -%>
                                <%= gap_tag %>
                              <% end -%>
                            <% end -%>
                          </ul>
                        <% end -%>

     - i gdy teraz odswizymy mamy ladna paginacjie

     **
     Teraz czas na zaimplementowanie listy
        views/categories/show.html.erb
              <h1><%= @category.name  %></h1>
                <%= render partial: 'products/products', locals: { products: @products } %>
                   <%= paginate @products %>

     **
     Teraz zajmijmy sie naszym parszalem   views/products/_products.html.erb
     - tak aby nie pobieraly danych w locie tylko pobieraly z naszego produktu

                   <% products.each_slice(3) do |slice| %>                                                       <!-- Bedziemy wyswietlac 9 elementow, wiec od 1 do 9 sobie wyliczymy i uzyjemy helpera  each_slice ktory nam podzieli te tablice na iles tablic, ktora kazda z nich bedzie zawierala po trzy elementy -->
                       <div class="row">                                                                        <!-- Produkty bedziemy wyswietlac w 3 kolumnach wiec uzyjemy systemu gird z bootstrapa -->
                         <% slice.each do |product| %>                                                          <!-- Kazda z tych trujek jest tablica po ktorej bedzimey literowac -->
                             <div class="col-md-4">                                                             <!-- Skoro chcemy 3 produkty w kazdym wierszu, i skoro mamy 12 kratek w naszym girdzie, to kazdy produkt zajmnie 1/3 z tych 12 czyli 4kratki   -->
                               <div class="thumbnail">
                                                                                      <!-- Z kolieji ta klasa jest klasa ktora reprezentuje miniaturke -->
                                 <%= link_to product_path(product) do %>
                                    <%= image_tag product.photo.url  %>
                                 <% end %>


                                 <div class="caption">
                                   <h3><%= link_to Faker::Hacker.noun.titleize, product_path(1) %></h3>                  <!-- Tu mamy nazwe produkut z uzyciem helpera Faker::Hacker.noun -->
                                   <p><%= simple_format(truncate(Faker::Hacker.say_something_smart, length: 90)) %></p>  <!--  Tutaj opis danego produktu, czyli jakies wygenerowane zdanie przez fakera -->
                                   <p class="lead"><%= number_to_currency Faker::Number.decimal(2, 2) %></p>             <!--  I tutaj cena danego produktu-->
                                   <p>
                                     <%= link_to "#", class: "btn btn-primary" do %>
                                         <span class="fa fa-shopping-cart"></span> Dodaj do koszyka             <!-- I tu mamy bardzo ciekawa klase bootstrapa fa dlatego ze mamy strone http://fontawesome.io  czyli ikonki, fa-to pierwsza klasa ze to fontawsome i druga klasa to opis ikonik-->
                                     <% end %>
                                   </p>
                                 </div>
                               </div>
                             </div>
                         <% end %>
                       </div>
                   <% end %>


           DO WYSTARTOWANIA API / Nie startuje CarrierWave ze zdjeciami
                - potrzeba nam kontrollra:
                     class ProductsController < ApplicationController
                       def index
                         @products = Product.order(created_at: :desc).limit(9)
                       end

                       def show
                         @product = Product.find(params[:id])
                         @category = @product.category
                       end
                     end
                - uploadera
                     class Product < ActiveRecord::Base
                       belongs_to :category

                       validates :name, presence: true                        # pole z nazwa nie moze byc puste
                       validates :description, presence: true                 # pole z opisem nie moze byc puste
                       validates :price, numericality: { greater_than: 0.0 }  # cena powinna byc wieksza niz zero i musi byc liczba
                       validates :category, presence: true                    # deklarujemy ze chcemy ja zwalidowac i przypozadkowac do kategorii


                       mount_uploader :photo, ProductPhotoUploader
                           # Musimy takze zamontowac nasz uploader pochodzacy z gemu CarrierWave
                           # Jako argument przkazujemy nazwe photo, ktora bedzie przechowywala sciezke do pliku
                           # Oraz nazwe klasy, ktora obsluguje dane uploadsy
                     end
                - chwilowo inspecta
                       <%= @products.each_slice(3) do |slice| %>                                                       <!-- Bedziemy wyswietlac 9 elementow, wiec od 1 do 9 sobie wyliczymy i uzyjemy helpera  each_slice ktory nam podzieli te tablice na iles tablic, ktora kazda z nich bedzie zawierala po trzy elementy -->
                           <div class="row">                                                                        <!-- Produkty bedziemy wyswietlac w 3 kolumnach wiec uzyjemy systemu gird z bootstrapa -->
                             <% slice.each do |product| %>                                                          <!-- Kazda z tych trujek jest tablica po ktorej bedzimey literowac -->
                                 <div class="col-md-4">                                                             <!-- Skoro chcemy 3 produkty w kazdym wierszu, i skoro mamy 12 kratek w naszym girdzie, to kazdy produkt zajmnie 1/3 z tych 12 czyli 4kratki   -->
                                   <div class="thumbnail">                                                          <!-- Z kolieji ta klasa jest klasa ktora reprezentuje miniaturke -->
                                     <%= link_to product_path(product) do %>
                                         <%= render text: @products.first.photo.url(:thumb).inspect  %>
                                     <% end %>
                                     <div class="caption">
                                       <h3><%= link_to Faker::Hacker.noun.titleize, product_path(1) %></h3>                  <!-- Tu mamy nazwe produkut z uzyciem helpera Faker::Hacker.noun -->
                                       <p><%= simple_format(truncate(Faker::Hacker.say_something_smart, length: 90)) %></p>  <!--  Tutaj opis danego produktu, czyli jakies wygenerowane zdanie przez fakera -->
                                       <p class="lead"><%= number_to_currency Faker::Number.decimal(2, 2) %></p>             <!--  I tutaj cena danego produktu-->
                                       <p>
                                         <%= link_to "#", class: "btn btn-primary" do %>
                                             <span class="fa fa-shopping-cart"></span> Dodaj do koszyka             <!-- I tu mamy bardzo ciekawa klase bootstrapa fa dlatego ze mamy strone http://fontawesome.io  czyli ikonki, fa-to pierwsza klasa ze to fontawsome i druga klasa to opis ikonik-->
                                         <% end %>
                                       </p>
                                     </div>
                                   </div>
                                 </div>
                             <% end %>
                           </div>
                       <% end %>





           UZUPELNIJMY DALSZA CZESC NASZEJ API
           - W parszalu products/_products.html.erb    wstawmy PRAWDZIWE DANE
                    <%= @products.each_slice(3) do |slice| %>                                                    <!-- Bedziemy wyswietlac 9 elementow, wiec od 1 do 9 sobie wyliczymy i uzyjemy helpera  each_slice ktory nam podzieli te tablice na iles tablic, ktora kazda z nich bedzie zawierala po trzy elementy -->
                        <div class="row">                                                                        <!-- Produkty bedziemy wyswietlac w 3 kolumnach wiec uzyjemy systemu gird z bootstrapa -->
                          <% slice.each do |product| %>                                                          <!-- Kazda z tych trujek jest tablica po ktorej bedzimey literowac -->
                              <div class="col-md-4">                                                             <!-- Skoro chcemy 3 produkty w kazdym wierszu, i skoro mamy 12 kratek w naszym girdzie, to kazdy produkt zajmnie 1/3 z tych 12 czyli 4kratki   -->
                                <div class="thumbnail">                                                          <!-- Z kolieji ta klasa jest klasa ktora reprezentuje miniaturke -->
                                  <%= link_to product_path(product) do %>
                                      <%= image_tag product.photo.url(:thumb).inspect  %>
                                  <% end %>
                                  <div class="caption">
                                    <h3><%= link_to product.name, product %></h3>                           <!-- Podaje prawdziwa nazwe produktu -->
                                    <p><%= simple_format(truncate(product.description, length: 90)) %></p>  <!--  Formatuje opis produktu -->
                                    <p class="lead"><%= number_to_currency product.price %></p>             <!--  I tutaj cena danego produktu -->
                                    <p>
                                      <%= link_to "#", class: "btn btn-primary" do %>
                                          <span class="fa fa-shopping-cart"></span> Dodaj do koszyka             <!-- I tu mamy bardzo ciekawa klase bootstrapa fa dlatego ze mamy strone http://fontawesome.io  czyli ikonki, fa-to pierwsza klasa ze to fontawsome i druga klasa to opis ikonik-->
                                      <% end %>
                                    </p>
                                  </div>
                                </div>
                              </div>
                          <% end %>
                        </div>
                    <% end %>

           - TERAZ CZAS NA STRONE GLOWNA
           - Najpierw musze wejsc do naszego kontrollera i ustawic co ma sie w nim wyswietlac w akcji index i show
                    def index
                        @products = Product.order(created_at: :desc).limit(9)      # Tutaj napierw musze znalezc produkt i wyswietlic malejaco i wybieramy 9 z nich
                    end

                    def show
                      @product = Product.find(params[:id])         # Tu znajdujmey losowy produkt i go wyswietlimy
                      @category = @product.category
                    end


           - gdy wejde na  strone glowna i odswieze, to widze ze to sa te same prokuty czyli z BD
           - Zacznijmy od akcji index

                      views/products/index.html.erb
                           <h1>Najnowsze produkty</h1>
                           <%= render partial: 'products', locals: { products: @products } %>      -> zmienimy nasza losowa zmienna i ustawimy na nasz @products
           - i gdy teraz wejdziemy na strone glówna bedziemy widzies 9 najnowszych produktow


           ** TERAZ WYSWIETLE SZCZEGOLY DANEGO PRODUKTU
             - zrobimy tak ze strona ze szczegolami bedzie wyswietlac prawdziwe dane z BD
             - musze wyedytowac plik
                          views/products/show.html.erb
                              **** i ten kod generujacy dane w locie
                                          <div class="container-fluid">
                                            <div class="col-md-5">                                                       <!-- Tutaj takze korzystamy z girda bootstrapowego, bedzie zajmowa 5/12 miejsca na takie rzeczy jak opis, nazwe produtkow, cenne -->
                                              <h1><%= Faker::Hacker.noun %></h1>
                                              <p class="lead"><%= Faker::Hacker.say_something_smart %></p>
                                              <%= simple_format(Faker::Lorem.paragraphs(3).join("\n\n")) %>

                                              <p class="lead"><%= number_to_currency(Faker::Number.decimal(2, 2)) %></p>
                                              <p>
                                                <%= link_to "#", class: "btn btn-primary" do %>
                                                  <span class="fa fa-shopping-cart">  Dodaj do koszyka </span>
                                                <% end %>
                                              </p>
                                            </div>
                                            <div class="col-md-7">                                                         <!-- A po prawej stronie mamy 7/12 zajmowanego miejsca, kiedy obrazek bedzie zbyd duzy na obszar jaki mu dano, to obrazek bedzie pomniejszony i dostosowany do danego miejsca  -->
                                              <%= image_tag Faker::Placeholdit.image("640x480", 'jpg', 'cccccc'), class: "img-responsive" %>
                                            </div>
                                          </div>
                              **** ZASTAPIE KODEM POBIERAJACYM DANE Z BD

                                       <div class="container-fluid">
                                         <div class="col-md-5">                                                       <!-- Tutaj takze korzystamy z girda bootstrapowego, bedzie zajmowa 5/12 miejsca na takie rzeczy jak opis, nazwe produtkow, cenne -->
                                           <h1><%= @product.name %></h1>
                                           <p class="lead"><%= @product.description %></p>
                                           <%= simple_format(@product.long_description) %>

                                           <p class="lead"><%= number_to_currency(@product.price) %></p>
                                           <p>
                                             <%= link_to "#", class: "btn btn-primary" do %>
                                               <span class="fa fa-shopping-cart">  Dodaj do koszyka </span>
                                             <% end %>
                                           </p>
                                         </div>
                                         <div class="col-md-7">
                                           <%= image_tag @product.photo.url(:details).inspect, class: "img-responsive" %>     --> DALEM INSPECTA NARAZIE NIE MA OBRAZKA
                                         </div>
                                       </div>


9.8 Usprawnienia_nawigacji_Optymalizacja_SEO
   - Tutaj zajmniemy sie nawigacja
   - sprawie ze aktulne kategorie beda sie ladnie podswietlac
       * aktualnie w bootsrapie nie ma ladnego podswietlania naszego sidebaru(paska bocznego) dlatego tez tym sie zajmniemy
         - dodamy wlasna regule css
         - app/assets/stylesheets/application.css
              /* Regula podswietlajaca nasz SIDEBAR - PASEK BOCZNY */
              .nav-sidebar > .active > a,
              .nav-sidebar > .active > a:hover,
              .nav-sidebar > .active > a:focus {
                  color: #fff;
                  background-color: #428bca;
              }

   - Teraz musimy przejsc do naszego pliku z layoutsem

             <% Category.all.each do |category| %>                                        <!-- Wyswitlmy teraz prawdziwe kategorie -->
                             <li <% if @category == category %>class="active"<% end %>>   <!-- dodamy klase active, ktora podswietla nam nazwe, czyli jezeli dana kategoria jest aktywna,  to podswietlamy tylko ta kategorie -->
                               <%= link_to category.name, category_path(category) %>      <!-- 1-argumenty to category, a 2gim argumentem bedzie sciezka do category -->
                             </li>
             <% end %>
       - i gdy teraz odsiezymy strone to wszystko dziala
       - ale gdy wejdziemy w szeczoly produktu to podswietlenie znika
       - musimy dodac w kontrolerze products zmienna  @category poniewz porównujemy ja z category <li <% if @category == category %>class="active"<% end %>>
              def show
                  @product = Product.find(params[:id])
                  @category = @product.category           # Zmienna pomocna w podswietlaniu sidebara i uzyta w layotsie
              end


   ** Czas na górna nawigacje
       - Linki musze podlinkowac do prawdziwych akcji
       - po drugie podswietlic link kiedy uzytkownik znajduje sie w danej akcji danego kontrollera
       - layouts/application.html.erb
       - kod docelowo wyglada tak
                        <ul class="nav navbar-nav">
                          <li <% if [params[:controller], params[:action]] == ["products", "index"] %>class="active"<% end %>><%= link_to "Start", root_path %></li>
                          <li <% if [params[:controller], params[:action]] == ["static", "privacy"] %>class="active"<% end %>><%= link_to "Polityka prywatności", privacy_path %></li>
                          <li <% if [params[:controller], params[:action]] == ["static", "terms"] %>class="active"<% end %>><%= link_to "Regulamin", terms_path %></li>
                          <li <% if [params[:controller], params[:action]] == ["static", "shipping"] %>class="active"<% end %>><%= link_to "Regulamin", shipping_path %></li>
                          <li <% if [params[:controller], params[:action]] == ["static", "about"] %>class="active"<% end %>><%= link_to "O sklepie", about_path %></li>
                        </ul>
                                <!-- Czyli tworze sobie tablice, w ktorej pierwsza z nich to nazwa kontrollera a druga nazwa akcji -->
                                <!-- I porównuje ja do aktulanego kontrolera w ktorym sie znajduje i akcji jakiej jestem -->
                                <!-- Jezeli jest taki sam to podswietlam akcjie -->


   ** Kiedy klikniemy w kategorie lub produkt, to w pasku widzimy categories i products ZPLOSZCZMY TO
          resources :products, only: [:show, :index], path: "produkt"       # nasz resources products bedzie posiadal tylko dwie akcje   SPOLSZCZMY NASZA NAZWE W PASKU UZWYAJAC OPCJI O NAZWIE PATH
          resources :categories, only: [:show] , path: "kategoria"          # dodatkowo zadeklarujemy kategorie                          I TU TAKZE SPOLSZCZMY
          root to: 'products#index'                                         #nasz glowny adres

   ** Dobrze by bylo aby w adresie URL znajdowala sie NAZWA PRODUKUTU
      - okazuje sie ze jestesmy to w stanie zrobic w sposob nie inwazyjny
      - wystrczy ze w metodzie dodamy to_parm

                 # dziki tej metodzie, bedziemy mogli wyswietlac nazwe danego produktu w pasku
                 # czyli zamiast products/id
                 # to products/nazwa_produktu
                 # domyslnie railsy zwarcaja id
                 # a w momecie te metode zformulujemy (pracujemy na modelu, path )

                     def to_param
                       "#{id}-#{name}".parameterize
                     end

      - i to samo dodajmy w produktach
      - i gdy teraz odswiezymy strone widzimy ze nasze nazwy wyswietlaja sie w oczekiwany sposob np: /kategoria/1-overriding
      - Dzieki tej prostej sztutce strona stala sie przyjazna dla SEO



9.9 Panel Admina
    ** Panel Admina bedzie CRUDEM  do zarzadzania modelami ( w tym przypadku dwoma, produktami i kategoriami)
     - Juz posiadamy kontroller z ktorego korzysta uzytkownik do przeglądania produktów
     - Wiec nie mozemy uzyc tego kontrollera do panelu admina
     - Ruby posiada tzw. przestrzen nazw
     - POJECIE PRZESTERZ NAZW   - czyli zamknosc klase w przestrzeni nazw, czyli w module
     - Nawet generatory rozumieja pojecie przestrzeni nazw

     * Na poczatek wygenerujemy kontrollery
       - dla produktów odrazu podamy liste akcji dla ktorych chcemy miec wygenerowane widoki

       rails g controller admin/products index new edit
       rails g controller admin/categories index new edit


     * Wchodząc w routsy widzimy ze railsy wygenerowaly nam odpowiednie sciezki, usunmy je i zmiennmy je na nasze
                   namespace :admin do
                     resources :products
                     resources :categories
                   end
     - mozemy poderzec sobie w rake routes

     ** Dobrze jest miec OSOBNY LAYOUTS dla panelu admina
       - dodatkowo wszystkie kontrollery w module admina zrobimy zachaslowane i tylko uzytkownik ktory zna haslo bedzie mógł dodawac usowac itd.

     **
     ****
       -> Dobra praktyka jest wygenerowanie kontrollera bazowego
          i z tego kontrollera beda dziedziczyc klasy kontrollerow dotyczacych admina produktow i kategori
          wygenerujemy go bez zadnych widokow, z niego bedziemy tylko dziedziczyc

          rails g controller admin/base

       -> Uzupelnijmy nasz kontroller bazowy


                  class Admin::BaseController < ApplicationController
                    layout 'admin'                                                                  # Wybieram layouts
                    before_action :authenticate                                                     # Uwiezytelniam uzytkownika, czyli nikt nie ma wstepu do panelu admina, chyba ze zna login i haslo

                    def authenticate                                                                # I tu jest nasze uwiezytelnienie uzytkownikow
                      authenticate_or_request_with_http_basic 'Podaj hasło!' do |name, password|
                        name == 'username' && password == 'secret'
                      end
                    end
                  end

      * Teraz wejdzmy do naszego admin/products_controller.rb
      - Mamy:

               class Admin::ProductsController < ApplicationController
                 def index
                 end

                 def new
                 end

                 def edit
                 end
               end

      - Ale my chcemy dziedziczyc po naszym base/contrloler wiec - to bardzo proste :

               class Admin::ProductsController < Admin::BaseController            # Czyli podpinamy nasz element apki :)
                 def index
                 end

                 def new
                 end

                 def edit
                 end
               end

      - I tak samo admin/categories_controller.rb

            class Admin::CategoriesController < Admin::BaseController             # Tez z naszej klasy bazowej bedzie dziedziczyc
              def index
              end

              def new
              end

              def edit
              end
            end

      ** Teraz musimy stworzyc layouts
         - layots   - tworzymy nowy:   admin.html.erb
         - I tak docelowo bedzie wygladal nasz panel admina, nic nadzwyczajnego

                     <!DOCTYPE html>
                     <html>
                     <head>
                       <title>ShopOnline</title>
                       <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track' => true %>
                       <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
                       <%= csrf_meta_tags %>
                     </head>
                     <body>
                     <nav class="navbar navbar-default navbar-static-top">
                       <div class="container">
                         <div class="navbar-header">
                           <a class="navbar-brand" href="<%= admin_root_path %>">ShopOnline::Admin</a>
                         </div>
                         <ul class="nav navbar-nav">
                           <li <% if params[:controller] == "admin/products" %>class="active"<% end %>><%= link_to "Produkty", admin_products_path %></li>
                           <li <% if params[:controller] == "admin/categories" %>class="active"<% end %>><%= link_to "Kategorie", admin_categories_path %></li>
                           <li <% if params[:controller] == "admin/orders" %>class="active"<% end %>><%= link_to "Zamówienia", admin_orders_path %></li>
                         </ul>
                       </div>
                     </nav>
                     <div class="container-fluid">
                       <%= bootstrap_flash %>
                       <%= yield %>
                     </div>
                     </body>
                     </html>



        ** Uzupelnijmy teraz nasz kontroller produktow CRUDOWY admina
                    class Admin::ProductsController < Admin::BaseController

                      def index
                        @products = @q.result(distinct: true).page(params[:page]).per(30)         # Zwyczajne pobranie wszystkich produktow i dodajemy paginacje przez kaminari
                      end

                      def new
                        @product = Product.new                                                     # Tutaj generujemy nowy formularz
                      end
                                                                                                   # Dalej standardowy CRUD
                      def create
                        @product = Product.new(product_params)
                        if @product.save
                          redirect_to admin_products_path, notice: "Pomyślnie dodano produkt."
                        else
                          render action: :new
                        end
                      end

                      def edit
                        @product = Product.find(params[:id])
                      end

                      def update
                        @product = Product.find(params[:id])
                        if @product.update_attributes(product_params)
                          redirect_to admin_products_path, notice: "Pomyślnie usunięto produkt"
                        else
                          render action: :edit
                        end
                      end

                      private

                      def product_params
                        params.require(:product).permit(
                            :name,
                            :category_id,
                            :description,
                            :long_description,
                            :price,
                            :photo
                        )
                      end
                    end


        - Podobnie kontroller z kategoriami admina
                class Admin::CategoriesController < Admin::BaseController
                  def index
                    @categories = Category.all
                  end

                  def new
                    @category = Category.new
                  end

                  def create
                    @category = Category.new(category_params)
                    if @category.save
                      redirect_to admin_categories_path, notice: "Pomyślnie dodano kategorię"
                    else
                      render action: :new
                    end
                  end

                  def edit
                    @category = Category.find(params[:id])
                  end

                  def update
                    @category = Category.find(params[:id])
                    if @category.update_attributes(category_params)
                      redirect_to admin_categories_path, notice: "Pomyślnie zmieniono kategorię"
                    else
                      render action: :edit
                    end
                  end

                  private

                  def category_params
                    params.require(:category).permit(:name)
                  end
                end



     ** Widoki admina - to kolejny etap pieknej zabawy z api - fac, this is very nice -zajebiste
     - views/admin/products/index.html.erb


                  <h1>Produkty</h1>

                  <%= link_to new_admin_product_path, class: "btn btn-success" do %>
                      <span class="fa fa-plus"></span> Dodaj nowy produkt               <!-- standardowy link prowadzacy do nowego produktu -->
                  <% end %>

                  <table class="table table-striped">       <!-- Tabelka z lista produktow -->
                    <thead>
                    <tr>
                      <th>Nazwa</th>
                      <th>Cena</th>
                      <th>Kategoria</th>
                      <th></th>
                    </tr>
                    </thead>
                    <tbody>
                    <% @products.each do |product| %>
                        <tr>
                          <td><%= product.name %></td>                       <!-- Oczywiscie nazwe -->
                          <td><%= number_to_currency product.price %></td>   <!-- Cene -->
                          <td><%= product.category.name %></td>              <!-- Nazwe kategorii -->
                          <td>
                            <%= link_to "Edycja", edit_admin_product_path(product), class: "btn btn-default btn-xs" %>     <!-- link do edycji produktu -->
                          </td>
                        </tr>
                    <% end %>
                    </tbody>
                  </table>

                  <%= paginate @products %>     <!-- Oczywiscie paginacje produktu -->




        ** Parszala z formularzem:
         - views/admin/products/_form.html.erb

                       <%= simple_form_for [:admin, @product] do |f| %>    <!-- Uzywamy tu zwyklego simple_forma, ktory jest zajebisty -->
                           <%= f.input :name %>
                           <%= f.input :description %>
                           <%= f.input :long_description %>
                           <%= f.input :price %>
                           <%= f.association :category %>
                           <%= f.input :photo %>
                           <%= f.submit %>
                       <% end %>


                       <!-- Bardzo ciekawa zecza jest to, ze simple_form_for
                            aby prowadzil nas do panelu admina a nie do zwyczajnego kontrollera to:
                            simple_form_for - wywolujemy dla tablicy
                            pierwszym elementem tablicy jest symbol admin,
                             - czyli symbolizuje nam namspaca czyli przestrzen nazw o nazwie admin
                            a drugim elementem jest konkretny obiekt z produktem
                            dzieki temu simple_form bedzie wskazywal na adminowy kontroller do obslugi danych z tego formularza
                            -->



        ** Jeszcze jedna wazna rzecz a mianowicie nasz root w adminie

                      namespace :admin do
                        root to:  'products#index'       # i taki zapis spowoduje ze wejscie do akcji /admin przekieruje nas na root glowny-strone glowna
                        resources :products
                        resources :categories
                      end

                      # gdy wpiszemy adres /admin/products  - to wejdziemy na products
                      # a co jezeli wpiszemy /admin - to tu takze powinien nas skierowac w odpowiednia akcje
                      # wiec dajemy root to: 'products#index'






     ** Sprobujmy teraz wejsc do naszego panelu admina http://localhost:3000/admin         uzytkownik: username, haslo:secret
        - gdy podamy login i haslo uzupelniamy je - i pojawia nam sie oczekiwana akcja
        - czyli panel admina


9.10 Ransack_Formularz_Przeszukiwania_Produktow
    * Zbudujemy prosty formularz do przeszukiwania produktow w panelu admina
    * Uzyjemy gema ransack   - ktory juz mamy dodany do panelu admina, mamy juz go dadanego do gemfilla
      - installacja gema jest standardowo bardzo prosta, wystarczy go dodac do gemfila i dac bundla
             gem 'ransack'
      - jego uzycie jest takze bardzo proste
      - Na Modelu wywolujemy metode ranstact i jako argument podajemy metode params od q  (params[:q])
             - Czyli mozemy wnioskowac, ze to w paramsach bedą znajdowac sie różne kryteria wyszukiwania
               i Ransac na podstawie tych kryteriów z paramsów - zbuduje odpowiednie kwerendy
               i nam zwróci odpowiednie rekordy wywolujac metode result na obiekcie q
                     :przykład z githuba   ->https://github.com/activerecord-hackery/ransack

                            @q = Person.ransack(params[:q])
                            @people = @q.result(distinct: true)
             - Ransacka, można dowolnie łączyc z paginacją itd.

     * Ransack udostepnia nam takze formBildera o nazwie:    search_form_for
        - w którym formularz budujemy dla obiektu q
                    ->Przyklad z githuba ransacka
                         <%= search_form_for @q do |f| %>

                           # Search if the name field contains...
                           <%= f.label :name_cont %>
                           <%= f.search_field :name_cont %>

                           # Search if an associated articles.title starts with...
                           <%= f.label :articles_title_start %>
                           <%= f.search_field :articles_title_start %>

                           # Attributes may be chained. Search multiple attributes for one value...
                           <%= f.label :name_or_description_or_email_or_articles_title_cont %>
                           <%= f.search_field :name_or_description_or_email_or_articles_title_cont %>

                           <%= f.submit %>
                         <% end %>
        - Budownaie formularzy w ransacku polega na tym ze budujemy pola o odpowiedniej nazwie i ta nazwa juz zawiera w sobie kwerende
           -> Przykladowo:
              - Jeżeli nasz model Person zawiera pole name
                to jezeli w formularzu wyszukiwania zrobimy name_cont
                to bedzie to skrót od name_conteins
                   - czyli name zawiera string który podamy w tym formularzu
                            # Search if the name field contains...
                             <%= f.label :name_cont %>
                             <%= f.search_field :name_cont %>
                   - albo, ze tytół artykulu zaczyna sie od stringa który podamy w tym polu
                            # Search if an associated articles.title starts with...
                              <%= f.label :articles_title_start %>
                              <%= f.search_field :articles_title_start %>
              - Wiec Ranstack udostepnia bardzo prosty sposób oparty na konwencjach na budowe formularzy wyszukiwania



       * Teraz taki formularz wyszukiwania zbudujemy dla naszego panelu admina
       * Wejdzmy teraz do panelu admina    http://localhost:3000/admin        username secret
       * Widzimy nasz standardowy panel


       ** Zacznijmy od kontrollera admina i zrobmy tak jak jest w dokumentacji
            class Admin::ProductsController < Admin::BaseController
            def index
                @q = Product.ransack(params[:q])                                         # - stworzmy nasza zmienna q
                @products = @q.result(distinct: true).page(params[:page]).per(30)        #  - a nastepnie do products przypiszmy nasze q i wywolanie metody result
                                                                                         # i chcemy unikalne rekordy tak zeby sie nie powtarzaly metoda: distinct: true
                                                                                         # Zwyczajne pobranie wszystkich produktow i dodajemy paginacje przez kaminari
            end

       * Teraz zamijmy sie naszym indexem

            <div class="search-form">
              <%= search_form_for [:admin, @q] do |f| %>                                                           <!-- Robimy search_form_for, pniewaz checmy zeby formularz wyszukiwania kierowal do panelu admina i podajemy w parametrach symbol admin i nasza zmienna q  -->
                  <%= f.text_field :name_or_description_or_long_description_cont, placeholder: "Szukaj tekstu" %>  <!-- I nasz formularz wyszukiwania bedzie zaweiral dawa pola,
                                                                                                                        i 1-sze nasze pole ma smieszna nazwe i ransack ja skanuje
                                                                                                                         i prubuje odkryc jaka kwerende mielismy na mysli
                                                                                                                        Czyli wpisanie jakiegos slowa sprawi ze Ransack bedzie szukal w kolumnach
                                                                                                                         description oraz long_description tego slowa i jezeli ktores z tych pol zawiera
                                                                                                                         to slowo ktore podamy w trybie wyszukiwania to produkt zostanie odnaleziony i
                                                                                                                         zostanie wyswietlony na liscie
                                                                                                                         -->
                  <%= f.text_field :price_gt, placeholder: "Cena >" %>              <!-- Naszym drugim polem jest price_qt i wszystkie produkty ktorych cena jest wieksza od
                                                                                     od wartosci ktora jest podana w tym polu, zostana znalezione i wyswietlone w liscie wyszukiwania -->
                  <%= f.submit "Szukaj" %>
              <% end %>
            </div>

       * Uruchomy nasz widok http://localhost:3000/admin/products
         - wyszukajmy np. wszytkie produkty ktorych cena jest wieksza niz 900
         - i teraz wszystkie ktore maja w nazwie np. system i tez wieksze niz 900
         - zauwazmy ze kryteria sie lacza

      ** Chcemy takze zeby nasz Ransack posortowal nam np jak kliknimy nazwie czy cene - klikajac naglówek
         - To bardzo proste
         - Ransack oferuje helpera o nazwie sort_link

                    <tr>
                       <th><%= sort_link(@q, :name, "Nazwa") %></th>    <!-- Posortujmy nasze produkty za pomoca helpera Ranstacka sort_link,
                                                                             pierwszym argumentem jest nasza zmienna q, a drugim argumentem jest nazwa pola
                                                                              po ktorym bedziemy sortowac(w tym przypadku jest to name)
                                                                              i trzecim argumenem ma byc tekst ktory jest w linku czyli nazwa-->
                       <th><%= sort_link(@q, :price, "Cena") %></th>    <!-- W tym przypadku podobnie -->
                       <th>Kategoria</th>
                       <th></th>
                     </tr>

        - I teraz jak odswiezymy strone to widzimy, ze nazwa jak i cena - sa linkami i jak je klikniemy
          dostajemy oczekiwany winik

9.11 Koszyk_plan
     ** Nasz koszyk bedzie pewnym stanem zamówienia (order-zamowienie)
        - Wiec przedewszytkime bedziemy potrzebowali modelu zamowienia-order
          ktory bedzie przechowywal wszystkie rzeczy jakie uzytkonik zamowil m.innymi tj:
                           - lista rzeczy,
                           - produktow,
                           - sposób i lista dostawy ,
                           - adres dostawy


     * Wiec stworzmy model (shipping_type) - wysylka,  potrzebny nam do tego, ktory bedzie zawieral nazwe jak również cene

              rails g model shipping_type name:string cost:decimal

                   *** decimal, dlatego ze ceny powinno sie przechowywac jako ulamki dziesietne, nigdy jako float
                       poniewaz floatsy gubią precyzje
                       a w przypadku pieniedzy jest to nieporzadane

     * Dodatkowo stworzmy model (address) -przechowujacy adres dostawy  (address)

               rails g model address first_name:string last_name:string city:string zip_code:string street:string email:string order:belongs_to

               czyli tworzymy model adsress o polach:
                     fist_name
                     last_name
                     city - miasto
                     zip_code - kod pocztowy
                     street - ulica
                     email
                     order:belongs_to   -> polaczymy ten model(address)  odrazu z naszym zamowieniem (order)

     * Czas na model (order)  - czyli zamowinie
       - dodamy mozliwosc zamieszczenia jakiegos komentarza (pole commenter:text)
       - zamowienie bedzie przechowywalo swój adres dostawy (shipping_type: belongs_to)
       - zamowienie bedzie takze przechowywalo koszst dostawy (shipping_cost:decimal)
                  UWAGA:
                  ** i tutaj rodzi sie pytanie?
                     - dlaczego przechowujemy koszt dostawy skoro przechowujemy ten koszt dostawy w modelu shipping_type
                       odpowiedz jest prosta
                          co jezeli uzytkownik zlozy zamowienie a my w BD zmienimy koszt dostawy
                          wtedy sumaryczne ceny wszystkich zamowien sie totalnie zepsuja
                          poniewaz zmienilismy jedna z cen skladowych, ktora wpywala na zamowienie
                          Natomiast jezeli w momencie skladania zamowienia bedziemy zapamietywac aktualna cene dostawy
                          i nawet jezeli w przyszlosci zmienimy ta cene w BD to starsze zamowienia beda przechowywac ta
                          starsza cene i w ten sposob nie wplynie to negatywnie na ceny wszystkich zamowien

               rails g model order comment:text shipping_type:belongs_to shipping_cost:decimal

                   czyli tworzymy model order o polach:
                         comment
                         shipping_type:belongs_to - wysylka, laczymy nasz model order z shipping_type
                         shipping_cost:decimal  - i w tym modelu dodatkowo cena


     * Kolejny model ktory bedzie przechowywal pozycje w zamowieniu line_item
       - i taka pozycja bedzie przechowywala odniesienie do produktu                 product:belongs_to
       - bedzie przechowywala cene za pojedynczy egzemplarz                          unit_price:decimal
       - jak rowniez bedzie przechowywala cene produktu
       - potrzebujemy jeszcze pola z liczba sztuk                                    quantity:integer
       - oraz zamowienia do jakiego dana pozycja nalerzy                             order:belongs_to
       - dobrze by bylo przechowac nazwe produktu w momencie dodania go do koszyka   item_name:string


       rails g model line_item product:belongs_to unit_price:decimal quantity:integer order:belongs_to item_name:string


     * Dobrze by bylo wygenerowac kolejny model typu mailer (order_mailer) - ktory bedzie wysylal uzytkownikowi stany zamowienia
           np:
              - przyjelismy zamowienie
              - zamowienie zostalo wyslane
              - zamowienie zostalo anulowane itd.

           order_mailer   - bedzie zawieral nastepujace wartosci:
              order_confirmation - czyli potwierdzenie zlozenia zamowienia
              order_in_progres   - czyli ze zamowienie wlasnie zostalo przyjete do realizacji
              order_shipped      - powiadomienie ze zamowienie wlasnie zostalo wyslane
              order_cancelled    - zamowienie zostalo anulowane

       rails g mailer order_mailer order_confirmation order_in_progress order_shipped order_cancelled


     * Na koniec  wygenerujemy nasz kontroller ktory bedzie sluzyl do obslugi koszyka
         cart -koszyk
         akcje:
               show
               edit
               confirmation  - czyli akcja pokazujaca koszyk z calym podsumowaniem i przyciskiem zlozenia zamowienia

         Nasz kontroller bedzie posiadal takze dodatkowe metody ktore nie beda posiadaly widokow
         tj. np: dodawanie produktow lub usowanie

         rails g controller cart show edit confirmation



     rake db:migrate
     - tu mi niestety nie dziala
     - wiec

     rake db:drop
     rake db:create
     rake db:setup
     rake db:seed
     rake db:migrate

     rails s
     - i smiga   - Fuck, this is fantastic :)


     * Teraz wejdzmy do konsoli rails i dodajmy dwa typy dostawy ktore uzytkownik bedzie mogl wybrac
       - 1 typ to typ dostawy poczta
       - 2 typ do kurier

       rails c
        ShippingType.create name: "Poczka Pocztowa", cost: 10.0
        ShippingType.create name: "Kurier", cost: 20.0

     * Teraz wstepnie skonfigurujemy nasze modele
         # MODEL-pierszy z nich to address
             - juz oczywiscie z generatora jest polonczony z zamoieniem(order)
             - ale warto dodac kilka regul walidacji
             - bedziemy walidowac imie, nazwisko, kod pocztowy, email i miasto

                       class Address < ActiveRecord::Base
                         belongs_to :order
                         validates :first_name, :last_name, :zip_code, :street, :email, :city, presence: true
                       end

         # MODEL-Drugi z nich to line_item czyli pozycja w zamowieniu
           - mamy juz polaczone modele
           - ale dodatkowo dodamy metode wyswietlajaca cene (czyli bedzie mnozyla cene pojedynczego egzemplarza z liczba sztuk)

                       class LineItem < ActiveRecord::Base
                         belongs_to :product
                         belongs_to :order

                         def full_price
                           unit_price * quantity
                         end
                       end

         # MODEL-trzeci do order - zamowienie
             - przedewszystkim musimy dodac fakt ze musimy miec wiele pozycji
                    class Order < ActiveRecord::Base
                      belongs_to :shipping_type
                      has_many :line_items       # przedewszystkim musimy dodac fakt ze musimy miec wiele pozycji
                      has_one :address           # datkowow zamowienie bedzie mialo jeden adres

                      # Metoda zwaracajaca sume calego zamowienia
                        # Na sume calego zamówienia skladaja sie dwie rzeczy:
                        #  - po pierwsze suma wszystkich pozycji w zamowieniu
                        #  - po drugie suma kosztow dostawy
                      def full_cost
                        line_items.map { |e| e.full_price }.sum + shipping_cost           # Najpierw sumujemy wszystkie pozycjie a nastepnie dodajmey koszt dostway
                      end
                    end

9.12 Maszyna stanów  STATESMAN
    * Skorzystamy jak zwykle z jednego z gemow jakie oferuja railsy
         https://github.com/gocardless/statesman


    * Maszyna stanów jest pojeciem matematycznym
      - jest pewna struktura ktora przechowuje różne stany i definjuje mozliwosc przejscia miedzy różnymi stanami
        Przykładowo:
           - W naszym zamówieniu bedziemy mieli rózne stany tj:
                     ^ nowe
                     ^ potwierdzone
                     ^ przyjete do realizacji
                     ^ wyslane
                     ^ anulowane
           - I bedziemy miec sciezke dojscia do róznych stanow
      - Krótko mówiąc jeżeli zamówienie bedzie w stanie potwierdzonym
        to jedynym stanem do którego zamówienie moze przejsc to jest przyjete do realizacji albo anulowane.
        A w momecie kiedy zamówienie bedzie przyjete do realizacji to jednym dozwolonym stanem bedzie albo wyslane
        lub anulowane.
      - Jak widzimy w dokumentacji STATESMAN oferuje (zerknijmy na dokumentacje)
           ^ mozliwosc zdefiniowania wszystkich stanow
                          state :pending, initial: true
                          state :checking_out
                          state :purchased
                          state :shipped
                          state :cancelled
                          state :failed
                          state :refunded
           ^ po drugie - zdefiniowania przejsc pomiedzy stanami
                           transition from: :pending,      to: [:checking_out, :cancelled]
                           transition from: :checking_out, to: [:purchased, :cancelled]
                           transition from: :purchased,    to: [:shipped, :failed]
                           transition from: :shipped,      to: :refunded
           ^ posiada takze metody chroniące przed przjsciem do stanów jezeli jakis warunk nie jest spelniony
                              guard_transition(to: :checking_out) do |order|
                                order.products_in_stock?
                              end
           ^ posiada takze callbeacki
             - ktory jest wywolany przed przejsciem z jednego stanu do innego
                       before_transition(from: :checking_out, to: :cancelled) do |order, transition|
                         order.reallocate_stock
                       end
             - w naszym przypadku jezeli bedziemy przechodzic ze stanu przyjete do realizacji do stanu wyslane
               to bedziemy wysylac juz tylko emaila
      - W dokumentacji mamy takze w jaki sposob skonfigurowac STATESMANA
        i sam Statesman uzywa w przykladach "Order" - jest to bardzo dobry przyklad maszyn stanow
                        class Order < ActiveRecord::Base
                          include Statesman::Adapters::ActiveRecordQueries

                          has_many :order_transitions, autosave: false

                          def state_machine
                            @state_machine ||= OrderStateMachine.new(self, transition_class: OrderTransition)
                          end

                          def self.transition_class
                            OrderTransition
                          end
                          private_class_method :transition_class

                          def self.initial_state
                            :pending
                          end
                          private_class_method :initial_state
                        end
      - Mamy takze sposób instalcji naszego gemu
               Persistence

               By default Statesman stores transition history in memory only.
               It can be persisted by configuring Statesman to use a different adapter.
               For example, ActiveRecord within Rails:

      ZACZNYIJMY ZABAWE Z NASZYM NOWYM GEMEM
      * Po piersze - przedewszystkim chcemy aby przejscia miedzy stanami byly przechowywane w bazie danych a nie w pamieci
        jak to domyslnie robi Statesman
        - musimy stworzyc plik  statesman.rb
        - i dodac do niego odpowiednia tresc

                  config/initializers/statesman.rb

                  Statesman.configure do
                    storage_adapter(Statesman::Adapters::ActiveRecord)
                  end
                  # I ten kod bedzie wywolywany za kazdym razem
                  # - kiedy bedzie uruchamiana nasz aplikacja
                  # - czyli w momecie startu serwera, konsoli lub testow

      * Po drugie potrzebujemy modelu
        - i tutaj takze skorzystamy z dokumentacji

               rails g statesman:active_record_transition Order OrderTransition

        - wejdzmy teraz do wygenerowanego modelu  order_transitions
        - i zmienimy tu jedna rzecz:
               ^ Widzimy ze jest napisane order_transitions ale my zmienimy na transitions
                     zmieniamy z :  belongs_to :order, inverse_of: :order_transitions
                               na:   belongs_to :order, inverse_of: :transitions
               ^ inverse_of - ogolnie opisuje nazwe stansakcji ktora jest w druga strone
                            - wiec jezeli zamowienie bedzie mialo wiele transitions, czyli przejsc
                              pomiedzy jednym stanem a drugim
                              to pojedyncze transitions oczywiscie bedzie nalezalo do zamoienia
                              ale bedzie tez opisywalo ze chodzi o odwrotna strone asocjacji transitions

      * Pozostalo nam reczne stworzenie maszyny stanow
             models/order_state_machine.rb


             class OrderStateMachine
               include Statesman::Machine

               # Definijemy nazw stanow
               state :new, initial: true      # Czyli zamowienie jest nowe, jest jeszcze koszykiem, nie zostalo zlozone
               state :confirmed               # Zostalo potwierdzone
               state :in_progress             # Zamówienie w trakcjie realizacji
               state :shipped                 # Zamówienie wyslane
               state :cancelled               # Zamowienie anulowane

               # Tutaj dodamy mozliwosci przejscia pomiedzy jednym stanem a drugim
               transition from: :new, to: [:confirmed, :cancelled]          # Czyli z koszyka mozemy przejsc z zamowienia potwierdzonego lub anulowanego
               transition from: :confirmed, to: [:in_progress, :cancelled]  # Z potweirdzonego mozemy przejsc do realizajci lub anulowanego
               transition from: :in_progress, to: [:shipped, :cancelled]    # Z realizacji mozemy przejsc do wyslanego lub anulowanego
               transition from: :shipped, to: [:cancelled]                  # Z wyslanego mozemy przejsc do anulowanego


               # Tutaj dodatkowo opiszemy co ma sie dziac gdy zamowienie przechodzi do stanu anulowanego
               after_transition(to: :cancelled) do |order, transition|
                 OrderMailer.order_cancelled(order).deliver               # Oczywiescie bedziemy wysylac maila informujacego ze zamowienie zostalo anulowane
               end

               after_transition(to: :confirmed) do |order, transition|
                 OrderMailer.order_confirmation(order).deliver            # Tu dziekujemy za zloznie zamowienia
               end

               after_transition(to: :in_progress) do |order, transition|
                 OrderMailer.order_in_progress(order).deliver             # Tu zamowienia przyjete do realizacji
               end

               after_transition(to: :shipped) do |order, transition|
                 OrderMailer.order_shipped(order).deliver                 # I tu inforamcaja ze zamowienie zostalo wyslane
               end


               # Tutaj mamy wlasna metode w ktorej nadajemy polski odpowiednik
               # - kazdemu ze stanu
               # - bedzie to nam sluzylo w panelu admina, aby wyswietlic  przyjazny dla administratora sklepu formularz, ktory pozowli na zmiane zamowienia
               def self.states_map
                 {
                     "new" => "Niepotwierdzone",
                     "confirmed" => "Złożone przez klienta",
                     "in_progress" => "Przyjęte do realizacji",
                     "shipped" => "Wysłane",
                     "cancelled" => "Anulowane",
                 }
               end
             end

      * Widzimy, ze uzywamy mailera - przejdzmy teraz do niego mailers/order_mailer.rb
        - widzimy tu serie plikow wygenerowanych przez generator
        - skasujmy je wszystkie
        - zaimplementujmy swoje

                class OrderMailer < ApplicationMailer

                  # i kazda z tych metod przyjmuje argument order
                  # i docelowo bedzie wysiwetlona w tresci maila
                  def order_confirmation(order)
                    @order = order
                    mail to: order.address.email, subject: "Dziękujemy za zamówienie"  # Oczywiscie mail wysylamy do podanego maila, oraz wysylamy wiadomosc o odpowiedniej tresci
                  end

                  def order_in_progress(order)
                    @order = order

                    mail to: order.address.email, subject: "Zamówienie w realizacji"
                  end

                  def order_shipped(order)
                    @order = order

                    mail to: order.address.email, subject: "Zamówienie wysłane"
                  end

                  def order_cancelled(order)
                    @order = order

                    mail to: order.address.email, subject: "Zamówienie anulowane"
                  end
                end

      * Wrócmy teraz do maszyny stanow
        - ogółem jest juz skonfigurowana
      * Ale dodatkowo musimy skonfigurowac nasz model order aby mogł z niej korzystac
        - i tu bedziemy korzystac calkowicie z dokumentacji
            app/models/order.rb



            class Order < ActiveRecord::Base

              include Statesman::Adapters::ActiveRecordQueries   # Dodaktowo zimplementujemy taki modół - umozliwiajacy przeprowadzanie kwerend na zamowieniu np; pokaz wszsytkie zamowienia ktore sa przyjete do realizacji

              belongs_to :shipping_type
              has_many :line_items       # przedewszystkim musimy dodac fakt ze musimy miec wiele pozycji
              has_one :address           # datkowow zamowienie bedzie mialo jeden adres


              has_many :transitions, class_name: "OrderTransition", autosave: false   # Na podstawie tej asocjacji STATESMAN bedzie obliczal w jakim aktualnie statusie jest zamowienie

              # Kolejna wazna rzecza jest delegacja
              # Dziala to m.wiecej tak
              # - jezeli bedziemy miec w kontrolerze jakies konkretne zamowienie @order i bedziemy chcieli przejsc do innego stanu to
              # - to zamist pisac cos takiego   @order.state_machine.transaction_to :confirmed
              # - to my napiszemy tak           @order.transition_to :confirmed
              # Czyli metoda delegate opisuje nazwy metod ktorych wywolanie bedzie oddegelowane do pozadanego obiektu
              delegate :can_transition_to?, :transition_to!, :transition_to, :current_state,
                       to: :state_machine

              # Druga rzecza jest zdefiniowanie metody state_machine dzieki ktorej bedziemy w stanie odwolac sie
              # - z poziomu zamowienia do naszej maszyny stanow opisujacej stan konkretnego zamowienia
              # I w tej metodzie tworzymy instancje klasy OrderStateMachine, czyli tej klasy ktora wczesniej zdefinowalismy
              #   - i odpowiednio ja konfigurujemy
              def state_machine
                @state_machine ||= OrderStateMachine.new(self, transition_class: OrderTransition, association_name: :transitions)
              end


              # Metoda zwaracajaca sume calego zamowienia
              # Na sume calego zamówienia skladaja sie dwie rzeczy:
              #  - po pierwsze suma wszystkich pozycji w zamowieniu
              #  - po drugie suma kosztow dostawy
              def full_cost
                line_items.map { |e| e.full_price }.sum + shipping_cost           # Najpierw sumujemy wszystkie pozycjie a nastepnie dodajmey koszt dostway
              end


              # Na koniec dodamy trzy metody ktore konfirguruja STATESMANA
              # Potrzebuje on informacji tj.
              def self.transition_class            # - klasy przechowujacej przejscie
                OrderTransition
              end

              def self.initial_state               # - domyslny stan
                OrderStateMachine.initial_state
              end

              def self.transition_name             # - nazwy asocjacji przychowujacej wszystkie przjescia
                :transitions
              end



            end


9.13 Dodawanie produktow do koszyka
     - uruchomy zalegla migracje, ktora stworzy tabele do przejsc dla zamowien

       rake db:migrate
       rails s

     - Zacznijmy od przejscia do application_controller.rb
     - Zdefiniowanie w kontrollerze jakiejkolwiek metody sprawi ze bedzie widoczna we wszystkich Kontrolerach naszej aplikacji
     - Poniewaz jest to sklep i w przyszlości bedzie rozbudowany o wiele innych kontrolerow
       warto by bylo miec globalny dostep do naszego koszyka
     - I tutaj zaimplementujemy metody, które znajdują nasz aktualny koszyk
     - Pierwsza metoda zwracajaca aktulany koszyk:
               current_cart

                     def current_cart                     # Ta metoda bedzie zwracala aktualny koszyk
                       if session[:order_id]              # Nr. koszyka czyli jego id bedzie przechowywane w sesii
                         Order.find(session[:order_id])   # i w momencie kiedy w przeglądarce użytkownika zapisany jest jakis koszyk, to zostanie odnalieziony w BD i zwrócony
                       else
                         Order.new                        # W przeciwnym razie kiedy w sesii nie ma zadenego koszyka - to zwracamy swiezy obiekt nie zapisany w BD
                       end
                     end

               Pada pytnie, czy bezpieczne jest przychowywanie id zamowienia w sesji ?
                 - co jesli jakis uzytkownik podmienie zamowienie na jakies inne ?
                   Odpowiedz jest prosta ponieważ wszytkie coocies sa szyfrowane

     - Druga metodą jest metoda która nam stworzy taki koszyk:
               current_cart_or_create

                        def current_cart_or_create           # metoda tworzaca koszyk
                          c = current_cart                   # pobieramy koszyk
                          if c.new_record?                   # jezeli koszyka jest nowym rekorderm
                            c.save                           # to zapisujemy go w BD
                            session[:order_id] = c.id        # Nastepnie zapamietujemy jego nr id w sesji
                          end
                          c                                  # i tutaj zwracamy koszyk
                        end

                                                             # i od teraz nasz current_cart bedzie zwracal nam zamowienie ktore stworzylismy i zapisalismy do BD


     - A o to caly ApplicationController

                class ApplicationController < ActionController::Base
                  # Prevent CSRF attacks by raising an exception.
                  # For APIs, you may want to use :null_session instead.
                  protect_from_forgery with: :exception


                  helper_method :current_cart

                  def current_cart                     # Ta metoda bedzie zwracala aktualny koszyk
                    if session[:order_id]              # Nr. koszyka czyli jego id bedzie przechowywane w sesii
                      Order.find(session[:order_id])   # i w momencie kiedy w przeglądarce użytkownika zapisany jest jakis koszyk, to zostanie odnalieziony w BD i zwrócony
                    else
                      Order.new                        # W przeciwnym razie kiedy w sesii nie ma zadenego koszyka - to zwracamy swiezy obiekt nie zapisany w BD
                    end
                  end


                  def current_cart_or_create           # metoda tworzaca koszyk
                    c = current_cart                   # pobieramy koszyk
                    if c.new_record?                   # jezeli koszyka jest nowym rekorderm
                      c.save                           # to zapisujemy go w BD
                      session[:order_id] = c.id        # Nastepnie zapamietujemy jego nr id w sesji
                    end
                    c                                  # i tutaj zwracamy koszyk
                  end
                                                       # i od teraz nasz current_cart bedzie zwracal nam zamowienie ktore stworzylismy i zapisalismy do BD

                end


     * Teraz stworzym w belce nawigacyjnej podgląd koszyka a w nim:
       - bedziemy chcieli wyswietlic liczbe produktow
       - oraz wyswietlic cene sumaryczna wszytkich produktow ktore mamy w koszyku

       ** Zeby to zrobic wykorzystamy metode current_cart ale, nie jest ona teraz dostepna w Widokach!!!
           - Ta metoda jest dostepna tylko z poziomu kontrollerów
           - Zeby sie do niej dostac z poziomu widoków - musimy dodac pewna sztuczkę
           - Railsy nam to udostepniaja po przez dodanie metody:

                  helper_method :current_cart

                  - dzieki temu ta metoda: current_cart jest dostepna we wszystkich widokach jako helper



     * Skoro mamy juz metody dodajmy teraz widok koszyka w belce nawigacjjnej w Layotsie:  views/layouts/application.html.erb

                                <!-- Koszyk  -->
                                <ul class="nav navbar-nav navbar-right">                                                 <!-- Nadajmy odpowiednia klase -->
                                  <li>
                                    <%= link_to "#cart_path" do %>                                                       <!-- Zalinkójmy nasz koszyk, jeszcze nie dziala -->
                                        <span class="fa fa-shopping-cart"></span>                                        <!-- Ladna ikone dajmy od font awsome -->
                                        <%= current_cart.line_items.map { |e| e.quantity }.sum %>                        <!-- Wyswietlimy liczbe wszystkich produktow -->
                                        produktów za
                                        <%= number_to_currency(current_cart.line_items.map { |e| e.full_price }.sum) %>  <!-- Wyswietlimy cene wszytkich produkotw -->
                                    <% end %>
                                  </li>
                                </ul>


     * Przejdzmy do naszych routsów i dodajmy nasze sciezki zwiazane z koszykiem

            # Koszyk
              # Tutaj mamy sciezki wygenerowane przez generator - nie chcemy ich
              #get 'cart/show'
              #get 'cart/edit'
              #get 'cart/confirmation'



              resource :cart, controller: "cart", only: [:show, :update, :edit] do    # resource pozwala nam okreslic doklanie do jakiego kontrollera ma prowadzic i okreslic jakie sciezki ma zawierac
                member do                                                             # i na konkretnym koszyku chcemy miec takie metody
                  post :add_product                                                   # metoda sluzaca do dodawania produktu
                  post :remove_product                                                # metoda do usówania produktu
                end
              end

     * Zmienimy sciezke dostepu w naszym layoutsie skoro mamy juz routsy

              <%= link_to cart_path do %>


              - Gdy uruchomiy serwer
                Widzimy ze wszystko smiga a po kliknieciu na koszyk, prowadzi nas do jego widoku
                ktorego jeszcze nie mamy

     * Zajmijmy sie teraz naszym przyciskiem - Dodaj do koszyka
     * Wejdzmy do naszego widoku show kontrollera products

          products/show.html.erb


          Póki co ten link nie prowadzi do niczego
          musimy podac link do akcji prowadzacy do koszyka

               <%= link_to add_product_cart_path(product_id: @product.id), method: :post, class: "btn btn-primary" do %>



               <div class="container-fluid">
                 <div class="col-md-5">                                                       <!-- Tutaj takze korzystamy z girda bootstrapowego, bedzie zajmowa 5/12 miejsca na takie rzeczy jak opis, nazwe produtkow, cenne -->
                   <h1><%= @product.name %></h1>
                   <p class="lead"><%= @product.description %></p>
                   <%= simple_format(@product.long_description) %>

                   <p class="lead"><%= number_to_currency(@product.price) %></p>
                   <p>
                     <%= link_to add_product_cart_path(product_id: @product.id), method: :post, class: "btn btn-primary" do %>   <!-- Musimy pamietac ze metoda add_product_cart_path jest postowa i musimy ja okreslic (method: :post).   -->
                       <span class="fa fa-shopping-cart">  Dodaj do koszyka </span>                                              <!-- Musimy takze wiedziec, ktory konkretnie produkt bedzie dodawany do koszyka, do kazdej sciezki dodamy argument w postaci hasha     -->
                     <% end %>                                                                                                   <!--   i ten hash bedzie zawarty w danych danego adresu url, wiec przekazemy product_id i przekazac id tego produktu  -->
                   </p>
                 </div>
                 <div class="col-md-7">
                   <%= image_tag @product.photo.url(:details).inspect, class: "img-responsive" %>
                 </div>
               </div>


           ** I jak teraz odwiezymy i najedziemy na przycisk dodaj do koszyka
              - widzimy id danego produktu


     * Drugim miejscem z ktorego mozna dodac produkt do koszyka jest lista produktow
       - musimy dostac sie do parshala z ta lista i podmienic link :
                _products.html.erb


                      <%= @products.each_slice(3) do |slice| %>                                                       <!-- Bedziemy wyswietlac 9 elementow, wiec od 1 do 9 sobie wyliczymy i uzyjemy helpera  each_slice ktory nam podzieli te tablice na iles tablic, ktora kazda z nich bedzie zawierala po trzy elementy -->
                          <div class="row">                                                                        <!-- Produkty bedziemy wyswietlac w 3 kolumnach wiec uzyjemy systemu gird z bootstrapa -->
                            <% slice.each do |product| %>                                                          <!-- Kazda z tych trujek jest tablica po ktorej bedzimey literowac -->
                                <div class="col-md-4">                                                             <!-- Skoro chcemy 3 produkty w kazdym wierszu, i skoro mamy 12 kratek w naszym girdzie, to kazdy produkt zajmnie 1/3 z tych 12 czyli 4kratki   -->
                                  <div class="thumbnail">                                                          <!-- Z kolieji ta klasa jest klasa ktora reprezentuje miniaturke -->
                                    <%= link_to product_path(product) do %>
                                        <%= image_tag product.photo.url(:thumb).inspect  %>
                                    <% end %>
                                    <div class="caption">
                                      <h3><%= link_to product.name, product %></h3>                           <!-- Podaje prawdziwa nazwe produktu -->
                                      <p><%= simple_format(truncate(product.description, length: 90)) %></p>  <!--  Formatuje opis produktu -->
                                      <p class="lead"><%= number_to_currency product.price %></p>             <!--  I tutaj cena danego produktu -->
                                      <p>
                                        <%= link_to add_product_cart_path(product_id: product.id), method: :post, class: "btn btn-primary" do %>          <!-- Tutaj również dodajemy nasza sciezke do koszyka -->
                                            <span class="fa fa-shopping-cart"></span> Dodaj do koszyka             <!-- I tu mamy bardzo ciekawa klase bootstrapa fa dlatego ze mamy strone http://fontawesome.io  czyli ikonki, fa-to pierwsza klasa ze to fontawsome i druga klasa to opis ikonik-->
                                        <% end %>
                                      </p>
                                    </div>
                                  </div>
                                </div>
                            <% end %>
                          </div>
                      <% end %>

                ** Jak odswiezymy strone to widzimy, ze adres url jest odpowiednio wygenerowany
                    - zarówno na stronie gownej jak i na stronie z konkretna kategoria

     * Zaimplementujmy teraz dodawanie i usowanie produktów do koszyka
       - Oczywiscie zrobimy to w naszym kontrollerze cart_controller.rb
         Implementacja bedzie wyglądała w taki sposob:

          class CartController < ApplicationController
            def show
            end

            def edit
            end

            def confirmation
            end


            def add_product
              order = current_cart_or_create                            # tworzymy i zapisujemy do BD
              product = Product.find(params[:product_id])               # znajdujemy produkt ktory chcemy dodac do koszyka
              if item = order.line_items.where(product: product).first  # i teraz kod ktoy sprawdza czy dany produkt jest juz w koszyku
                item.quantity += 1                                      # i jezeli jest to zwiekszamy o jeden
                item.save                                               # i zapisujemy
              else                                                          # Jezeli nie ma to tworzymy liczbe na fakturze
                order.line_items.create product: product,                   # Zapisujemy produkt
                                        quantity: 1,                        # tworzymy liczbe
                                        unit_price: product.price,          # zapisujemy aktualna cene produktu
                                        item_name: product.name             # oraz nazwe produktu
              end
              redirect_to :back, notice: "Dodano produkt do koszyka"        # i po dodaniu koszyka, wracamy do poprzedniej strony z komunikatem ze dodano do koszyka
            end



            def remove_product                                          # Usówanie prodkutków z koszyka jest nieco prostsza
              order = current_cart                                      # szukamy aktualnego koszyka
              product = Product.find(params[:product_id])               # znajdujemy produkt z ktorego id jest podany w paramsach
              item = order.line_items.where(product: product).first     # szukamy pozycji w koszyku ktora odwoluje sie do znalezionego przez nas produktu
              if item                                                      # jezeli taka pozycja istnieje
                item.destroy                                               # to usówamy ja
              end
              redirect_to :back, notice: "Usunięto produkt z koszyka"      # po usunieciu wracamy na poprzednią strone
            end                                                            # Jezeli podamy BACK to zawsze wracamy na poprzednią strone - niezaleznie jaka ona jest


          end


     * Wrócmy do przegladaraki i spróbujmy dodac jakis produkt
       - Nie widzimy zadnego komunikatu ze cokolwiek zostalo dodane , zmienmy to
       - W layotsie dodajmy helpera bootstrapowego flash

                         <div class="col-md-8">
                           <%= bootstrap_flash %>
                           <%= yield %>
                         </div>
          - Teraz juz widzimy nasz komunikat


     * Zajmijmy sie teraz widokiem show naszego koszyka
     * Najpierw musimy zainicjowac nasz kontroller akcji show
              def show
                @cart = current_cart
              end
     * Widok show tego kontrollera views/cart/show.html.erb

                           <h1>Twój koszyk</h1>
                           <% if @cart.line_items.empty? %>           <!-- Jezeli nie ma zadnych pozycji w koszyku to wyswietlamy komunikat ze koszyk jest pusty -->
                               <p>Twój koszyk jest pusty!</p>
                           <% else %>                                 <!-- W przeciwnym wypadku wyswietlamy tabelke z odpowiednia trescia -->
                               <table class="table table-striped">
                                 <thead>
                                 <th>Produkt</th>
                                 <th>Liczba sztuk</th>
                                 <th>Cena jednostkowa</th>
                                 <th>Cena całkowita</th>
                                 <th></th>
                                 </thead>
                                 <tbody>
                                 <% @cart.line_items.each do |line_item| %>
                                     <tr>
                                       <td><%= link_to line_item.item_name, product_path(line_item.product) %>
                                       <td><%= line_item.quantity %></td>
                                       <td><%= number_to_currency line_item.unit_price %></td>
                                       <td><%= number_to_currency line_item.full_price %></td>
                                       <td>
                                         <%= link_to remove_product_cart_path(product_id: line_item.product.id), method: :post do %>       <!-- Usowanie, musimy pamietac ze ten link jest postowy i musimy dodac method: :post -->
                                             <span class="fa fa-trash-o"></span>
                                         <% end %>
                                       </td>
                                     </tr>
                                 <% end %>
                                 </tbody>
                               </table>

                               <p>
                                 <%= link_to edit_cart_path, class: "btn btn-success btn-lg" do %>          <!-- A tutaj damy linka aby przejsc dalej -->
                                     Przejdź dalej
                                     <span class="fa fa-step-forward"></span>
                                 <% end %>
                               </p>
                           <% end %>


     * Tym razem zajme sie edycja naszego koszyka
       W momecie kiedy uzytkownik zapisze swój koszyk i wybierze sposób dostawy i doda komentarz
       to bedzie maiał przycisk, który bedzie prowadził do nastepnego ekranu czyli do potwierdzenia złożenia
       zamówienia.
       I tam uzytkownik bedzie mógł zobaczyc podsumowanie swojego zamówienia
         - ile bedzie razem kosztowało z kosztem dostawy
         - i bedzie mógł kliknąc przycisk który ostatecznie złozy zamówienie
         - ta akcja bedzie akacja getowa i bedzie nosic nazwe confirmation
                  * Zacznijmy od Routsów i ustawmy sciezki
                         resource :cart, controller: "cart", only: [:show, :update, :edit] do    # resource pozwala nam okreslic doklanie do jakiego kontrollera ma prowadzic i okreslic jakie sciezki ma zawierac
                            member do                                                             # i na konkretnym koszyku chcemy miec takie metody
                              post :add_product                                                   # metoda sluzaca do dodawania produktu
                              post :remove_product                                                # metoda do usówania produktu
                              get  :confirmation                                                  # a tutaj nowa akcja, czyli to bedzie przycisk który bedzie potwierdzał zamówienie
                            end
                          end

       ** Idzimy teraz do naszego formularza  cart/edit  w ktorym umozliwimy takie rzeczy jak
           - dodanie komentarza
           - sposób dostawy
           - oraz edycja adresu dostawy

           ???
           I tutaj pojawia sie pytnie
           W jaki sposób dodac adres dostawy do zamówienia - przeciez to jest nowy obiekt
           Okazuje sie ze RAILSY dodaly mozliwosc edycji wielu obiektów naraz w jednym formularzu
            - ale pod warunkiem oczywiscie ze istnieja jakies asocjacje pomiedzy tymi obiektami
              Funkcjonalosc ta nazywa sie:
                                           nested attributes

            - Otwórzmy nasze modele i zainicjujmy nasze połączenie
                  * W pierwszej kolejnosci nasz model Order
                    a w nim zadeklarujmy ze chcemy uzyc tej asocjacji dla modelu address
                    i deklaracje podajemey z argumentem acceptes

                    models/order.rb

                        accepts_nested_attributes_for :address      # czyli deklarujemy ze akceptujemy zagnieżdzone atrybuty dla tej asocjacji
                                                                     # i od tego momentu gdy na klasie Order wywołamy metode np update_attributes
                                                                     # to atrybuty z adresem takze beda przetwarzane
                                                                     # i odpowiednie rekordy zostaną zapisane do BD
                                                                     # Dodajemy to poniewaz pojawia sie pytanie
                                                                     # W jaki sposób dodac adres dostawy do zamówienia - przeciez to jest nowy obiekt
                                                                     # Okazuje sie ze RAILSY dodaly mozliwosc edycji wielu obiektów naraz w jednym formularzu











































